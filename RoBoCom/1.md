## RoBoCom

### preface

ä¸æ”¶å½•å¤§æ°´é¢˜ï¼Œè€ƒç ”ä¹‹ä½™çš„æ”¾æ¾å§ï¼Œåˆ·é¢˜èƒ½éº»æœ¨è‡ªå·±ğŸ˜­

å‚»é€¼æ¨¡æ‹Ÿé¢˜ä¸€é“ä¹Ÿä¸å¯èƒ½å†åšäº†ï¼Œçº¯ç²¹çš„æµªè´¹æ—¶é—´ï¼Œæµªè´¹ç”Ÿå‘½ï¼

### template

```  c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 1e5 + 10;

void solve()
{
    
}

int main()
{
    solve();
    return 0;
}
```



### 2021 é«˜èŒç»„

#### åˆèµ› 6 æ¨¡æ‹Ÿ

åœ¨è¿™ä¸ªäºŒç»´ç åæ ‡ç³»ä¸­ï¼Œè¡Œå…¶å®æ˜¯åˆ—ï¼Œåˆ—å…¶å®æ˜¯è¡Œï¼Œå·¦ä¸‹è§’ä¸ºï¼ˆ1ï¼Œ1ï¼‰ï¼Œå³ä¸Šè§’ä¸ºï¼ˆnï¼Œnï¼‰

``` c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 110;

// case1: 4ä½æ•´æ•°
// case2: ä¸¤å°é—®
// case3ï¼šåˆ†æ•°

int n, m;
bool s[N][N];

void split(string s, int &x, int &y)
{
    int pos;
    if((pos = s.find(";")) != -1) // case3
    {
        x = stoi(s.substr(0, pos));
        y = stoi(s.substr(pos + 1));
    }
    else if((pos = s.find("/")) != -1) // case2
    {
        x = stoi(s.substr(0, pos));
        y = stoi(s.substr(pos + 1));
    }
    else // case1 
    {
        while(s.size() < 4) s = "0" + s;
        x = stoi(s.substr(0, 2));
        y = stoi(s.substr(2));
    }
    // cout << x << ' ' << y << endl;
}

void solve()
{
    cin >> n >> m;
    while(m -- )
    {
        string str;   cin >> str;
        int x = 0, y = 0;
        split(str, x, y);
        // 1->n
        // 2->n-1
        // n->1
        // x->y
        // --> x+y=n+1
        // --> y=n+1-x
        s[n + 1 - y][x] = true;
    }
    for(int i = 1; i <= n; i ++ )
    {
        for(int j = 1; j <= n; j ++ )
        {
            if(s[i][j]) cout << "#";
            else    cout << ".";
        }
        cout << endl;
    }
}

int main()
{
    solve();
    return 0;
}
```

#### åˆèµ› 7 sort

è¿™é‡Œä¸ç”¨çœŸsortï¼Œç›´æ¥åˆ©ç”¨mapå³å¯ã€‚

``` c++
// å­—å…¸åºé€’å‡è¾“å‡ºä¸¢å¤±çš„ç¥¨æ®çš„ç¼–å·
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 110;

void solve()
{
    // map ç¬¬ä¸‰ä¸ªå‚æ•°å¯ä»¥æŒ‡å®škeyçš„æ’åº
    map<string,int, greater<string>> ass;
    int x;  cin >> x;
    while(x -- )    
    {
        string s;   cin >> s;
        // cout << "1: " << s << endl;
        ass[s] ++ ;
    }
    int y;  cin >> y;
    while(y -- )
    {
        string s;   cin >> s;
        // cout << "2: " << s << endl;
        ass[s] -- ;
    }
    for(auto &t : ass)
        if(t.second)
            for(int i = 0; i < t.second; i ++ )
                cout << t.first << endl;
}

int main()
{
    solve();
    return 0;
}
```



#### å¤èµ› 2 è¿›åˆ¶è½¬æ¢

æœ‰ä¸€ä¸ªç‚¹ï¼šå½“æˆ‘ä»¬å°†10è¿›åˆ¶è½¬æ¢ä¸ºå…¶ä»–è¿›åˆ¶æ—¶ï¼Œå¦‚æœä½¿ç”¨è¾—è½¬ç›¸é™¤æ³•ï¼Œéœ€è¦ç‰¹åˆ¤10è¿›åˆ¶æ•°ä½0çš„æƒ…å†µã€‚

``` c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 1e5 + 10;

void doSolve(string s, int pre, int n)
{
    // convert to 10p
    int num = 0;
    for(auto &x : s)
    {
        if(isdigit(x)) // 0-9
            num = num * pre + (x - '0');
        else    
            num = num * pre + (x - 'A' + 10);
    }
    if(pre == 27)  
    {
        cout << num << endl;
        return ;
    }
    // convert to np
    if(!num)    // special judge
    {
        cout << 0 << endl;
        return ;
    }
    string res("");
    while(num) // if num==0, will not execute
    {
        int t = num % 27;
        if(t < 10)  res += to_string(t);
        else    res += char('A' + (t - 10));
        num /= 27;
    }
    reverse(res.begin(), res.end());
    cout << res << endl;
}

void solve()
{
    int T = 1;
    while(T -- )
    {
        string s;   int n;
        cin >> s >> n;
        doSolve(s, n, 37 - n);
    }
}

int main()
{
    solve();
    return 0;
}
```

#### å¤èµ›







----



### 2021 æœ¬ç§‘ç»„

#### åˆèµ› 1 é¢„å¤„ç†+æš´åŠ›

``` c++
// å­—å…¸åºé€’å‡è¾“å‡ºä¸¢å¤±çš„ç¥¨æ®çš„ç¼–å·
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 110;

int n, k;
int w[N];
unordered_set<int> ass; 
    
void solve()
{
    cin >> n >> k;
    for(int i = 0; i < n; i ++ )    cin >> w[i];
    
    for(int i = 0; i < n; i ++ )
        for(int j = i + 1; j < n; j ++ )
            for(int p = j + 1; p < n; p ++ )
                for(int q = p + 1; q < n; q ++ )    
                    // éœ€è¦åˆ¤æ–­ä¸€ä¸‹èƒ½å¦æ•´é™¤
                    if((w[i] + w[j] + w[p] + w[q]) % 4 == 0)
                        ass.insert((w[i] + w[j] + w[p] + w[q]) / 4);
    
    while(k -- )
    {
        int cnt;    cin >> cnt;
        bool flag = true;
        while(cnt -- )
        {
            int x;  cin >> x;
            if(!ass.count(x))   
            {
                flag = false;
                // cout << "x: " << x << endl;
                // break; // ä¸èƒ½breakï¼Œå¦åˆ™ä¼šä¸­æ–­æ•°æ®çš„è¯»å…¥
            }
        }
        if(flag)    puts("Yes");
        else    puts("No");
    }
}

int main()
{
    solve();
    return 0;
}
```

#### åˆèµ› 2 è´ªå¿ƒ+æ’åº

æ¯”è¾ƒæœ‰è´¨é‡çš„ä¸€é¢˜ï¼Œä½†æ˜¯æ•°æ®å¯èƒ½æ¯”è¾ƒæ°´ï¼Ÿ

``` c++
// è´ªå¿ƒï¼Œæšä¸¾æ–œç‡
// å¯¹äºæ¯ä¸ªæ–œç‡ä¸Šçš„æ‰€æœ‰æœ¨æ£‹
// å¦‚æœä»·å€¼ä¸º1ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨æ–¹æ¡ˆ2
// å¦‚æœä»·å€¼ä¸ä¸º1ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨æ–¹æ¡ˆ1

#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 1e5 + 10;

// æ–œç‡ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªä¿å­˜xåæ ‡å³å¯
// å¯¹äº (0,y) è¿™ç§ç±»å‹ï¼Œå­˜å‚¨yåæ ‡
// string->æ–œç‡ï¼Œvector<PII> å­˜å‚¨ä¸€ä¸ªåæ ‡å’Œä»·å€¼
unordered_map<string, vector<PII>> ass;
int n;

int gcd(int a, int b)
{
    return (a % b) ? gcd(b, a % b) : b;
}

string getk(int a, int b)
{
    return to_string(a) + "," + to_string(b);
}

void solve()
{
    cin >> n;
    for(int i = 0; i < n; i ++ )
    {
        int x, y, c;
        cin >> x >> y >> c;
        // é¢„å¤„ç†
        if(!x) // (0,y)
        {
            int sign = y > 0 ? 1 : -1;
            ass[getk(0,-1 * sign)].push_back({y, c});
        }
        else if(!y) // (x,0)
        {
            int sign = x > 0 ? 1 : -1;
            ass[getk(sign * 1,0)].push_back({x, c});
        }
        else // x && y 
        {
            int sign = x > 0 ? 1 : -1;
            int d = gcd(x, y);
            int a = x / d, b = y / d;
            ass[getk(sign * a,b)].push_back({x, c});
        } 
    }
    int res = 0, cnt = 0;
    for(auto &it : ass)
    {
        // cout << "[" << it.first << "]: ";
        // for(auto &x : it.second)    cout << x.second << ' ';
        // cout << endl;
        
        // è®°å¾—æ’åºï¼Œé™åºè¿˜æ˜¯å‡åºä¸é‡è¦ï¼Œå› ä¸ºä¸å½±å“è¿ç»­çš„1åœ¨ä¸€èµ·
        sort(it.second.begin(), it.second.end());
        bool is_one = false;
        for(auto &[x,c] : it.second)
        {
            if(c != 1)  is_one = false, cnt ++ ;
            else if(!is_one)   cnt ++ , is_one = true;
            res += c;
        }
    }
    cout << res << ' ' << cnt << endl;
}

int main()
{
    solve();
    return 0;
}
```



#### åˆèµ› 3 æœ€çŸ­è·¯ + æ¨¡æ‹Ÿ

æœ€åä¸€ä¸ªç‚¹è¶…æ—¶ï¼Œå› ä¸ºè¾¹æ•°å¯èƒ½æ— é™å¤§

å› æ­¤æ­£ç¡®æ–¹æ³•ä¸º O(N^3) çš„æœ´ç´  dijkstra æˆ–è€…floyd

``` c++
/*
æ‰“è´¥æ€ªå…½éœ€è¦çš„èƒ½é‡ç­‰äºæ€ªå…½æœ¬èº«çš„èƒ½é‡
è€Œæ€ªå…½ä¸€æ—¦è¢«æ‰“è´¥ï¼Œæ­¦å™¨å°±å½’ç©å®¶æ‰€æœ‰ â€”â€” å½“ç„¶ç¼´è·çš„æ­¦å™¨ä»·å€¼è¶Šé«˜ï¼Œç©å®¶å°±è¶Šå¼€å¿ƒã€‚
*/

#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>
#include <queue>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 1e3 + 10, M = 2e6 + 10;

int n, m, root;
int h[N], e[M], ne[M], w1[M], w2[M], idx;
int dist[N], val[N], pre[N];
bool st[N];

void add(int a, int b, int c1, int c2)
{
    w1[idx] = c1, w2[idx] = c2;
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void init()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while (m -- )
    {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        add(a, b, c, d);
        add(b, a, c, d);
    }
}

int spfa(int u)
{
    memset(st, false, sizeof st);
    memset(val, 0, sizeof val);
    memset(pre, -1, sizeof pre);
    memset(dist, 0x3f, sizeof dist);
    
    queue<int> q;   q.push(u);
    st[u] = true;   dist[u] = 0;
    while(q.size())
    {
        auto t = q.front(); q.pop();
        st[t] = false;
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t] + w1[i])
            {
                dist[j] = dist[t] + w1[i];
                val[j] = val[t] + w2[i];
                pre[j] = t;
                if(!st[j])  q.push(j), st[j] = true;
            }
            else if(dist[j] == dist[t] + w1[i])
            {
                if(val[j] < val[t] + w2[i])
                {
                    val[j] = val[t] + w2[i];
                    pre[j] = t;
                    if(!st[j])  q.push(j), st[j] = true;
                }
            }
        }
    }
    // åŠ©åŠ›äº†ï¼Œé¢˜ç›®è¯´çš„æ˜¯æ‰€æœ‰å ¡å’ï¼Œè€Œä¸ä»…ä»…æ˜¯åé¢æˆ‘ä»¬è¦æ”»å…‹çš„å ¡å’ï¼Œcase2å’Œcase3
    int maxn = 0;
    for(int x = 1; x <= n; x ++ )  maxn = max(maxn, dist[x]);
    return maxn;
}

void getPos() // æ‰¾åˆ°ç©ºé™åœ°ç‚¹
{
    int minx = 2e9;
    for(int i = 1; i <= n; i ++ )
    {
        int cur = spfa(i);
        if(cur < minx)    root = i, minx = cur;
    }
    cout << root << endl;
}

// è¿˜æ˜¯dfsæ¼‚äº®
void dfs(int u)
{
    if(pre[u] == -1)    return ;
    dfs(pre[u]);
    cout << "->" << u;   
}

void outPath()
{
    int k;  cin >> k;
    while(k -- )    
    {
        int x;  cin >> x;
        cout << root;
        dfs(x);
        cout << endl;
        cout << dist[x] << ' ' << val[x] << endl;
    }
}

void solve()
{
    init();
    getPos();
    // å› ä¸ºspfaä¼šæ›´æ–°èµ·ç‚¹ï¼Œæ‰€ä»¥éœ€è¦è®¾ç½®preä¸º-1
    pre[root] = -1;
    spfa(root);
    outPath();
}

int main()
{
    solve();
    return 0;
}
```

#### åˆèµ› 4 é€†å‘æ€ç»´ ï¼ˆå¥½é¢˜ï¼‰

æ ·ä¾‹è§£é‡Šï¼š

``` c++
åŒå‘ï¼š
5 5 3
1 2
1 3
1 5
2 5
3 4

d1:4 3 -> 1
1 3
1 4
2 3

d2:5 3 -> 2
3 4
2 3
3 5

d3:1 3 -> 3
2 3
2 5
3 4
```

é¢˜ç›®å¤§æ„

> ç»™å®šæˆ‘ä»¬ä¸€ä¸ªå›¾ï¼Œä¾æ¬¡åˆ å»ä¸€ä¸ªç‚¹ï¼Œé—®è¿é€šçš„è¾¹çš„ä¸ªæ•°ï¼Œè¿™åº”è¯¥æ˜¯å¾ˆ**â€œç»å…¸â€**çš„é—®é¢˜äº†ï¼Œè€ƒè™‘è¿é€šæ€§ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹¶æŸ¥é›†ï¼Œä½†æ˜¯å¹¶æŸ¥é›†æ— æ³•å¤„ç†åˆ è¾¹ã€‚

æ€è·¯

> æˆ‘ä»¬å¯ä»¥é€†å‘æ€è€ƒï¼Œæ­£å‘åˆ è¾¹ï¼Œä¸å°±æ˜¯åå‘åŠ è¾¹å—ï¼Ÿäºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä¿å­˜æŸ¥è¯¢ï¼Œç„¶åå€’åºå¤„ç†ï¼Œä¾æ¬¡åŠ è¾¹ï¼Œç„¶åç”¨å¹¶æŸ¥é›†å°±å¯ä»¥äº†ã€‚

ä»£ç 

``` C++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <set>

using namespace std;

typedef long long ll;
typedef pair<int, int> PII;

const int N = 50010;

int n, m, d;
bool st[N]; // st[i]=true --> ç‚¹iè¢«åˆ é™¤
vector<int> res, ver;   // ä¿å­˜ç­”æ¡ˆå’Œåˆ é™¤çš„èŠ‚ç‚¹
vector<vector<PII>> q;   // ä¿å­˜æŸ¥è¯¢
vector<int> g[N]; // ä¿å­˜å›¾ä¸­çš„è¾¹
int pre[N]; // å¹¶æŸ¥é›†

int find(int x)
{
    if(pre[x] == x) return x;
    return pre[x] = find(pre[x]);
}

void init()
{
    cin >> n >> m >> d;
    while(m -- )
    {
        int a, b;   cin >> a >> b;
        // åŒå‘è¾¹
        g[a].push_back(b);  g[b].push_back(a);
    }
    for(int i = 0; i < d; i ++ )
    {
        int c, k;   cin >> c >> k;
        st[c] = true;   ver.push_back(c); 
        vector<PII> thisq;
        while(k -- )
        {
            int a, b;   cin >> a >> b;
            thisq.push_back({a, b});
        }
        q.push_back(thisq);
    }
    /*---------*/
    for(int i = 1; i < N; i ++ )    pre[i] = i;
}

void add_edge()
{
    for(int i = 1; i <= n; i ++ )
    {
        if(!st[i])
        {
            for(auto &ne : g[i])
            {
                if(!st[ne]) pre[find(i)] = find(ne); 
            }
        }
    }
}

void query()
{
    vector<int> res;
    for(int i = d - 1; i >= 0; i -- )
    {
        auto thisq = q[i];
        int u = ver[i];
        int cnt = 0;
        // do query
        for(auto &[a,b] : thisq)
            if(find(a) != find(b))  cnt ++ ;
        res.push_back(cnt);
        // add edge
        st[u] = false;
        for(auto &ne : g[u])
            if(!st[ne]) pre[find(u)] = find(ne);
    }
    // å€’ç€è¾“å‡º
    for(int i = d - 1; i >= 0; i -- )   cout << res[i] << endl;
}

void solve()
{
    init();
    add_edge();
    query();
}

int main()
{
    solve();
    return 0;
}
```

